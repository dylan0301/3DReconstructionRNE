# 1.
# 모든 점 pair 에 대한 거리 정보를 계산한다. -> dictionary
# 한 점 P에 대하여 그 점으로부터 거리가 가장 가까운 friend개의 점을 본다.
# 노이즈 제거 (radius outlier removal)
# friend개의 점 중에서 P와 거리가 r 이상인 점들을 뺐을 때 남은 점이 OutlierThreshold개 이하라면
# 점 P는 이상 포인트로 취급하고 점 P를 제거한다.
# 
점 P와 nearby를 포함하는 평면을 Ransac으로 찾는다.
이 평면의 법선벡터 하나를 고른다.
점 P를 시점으로, nearby 점을 종점으로 하는 벡터들에서 2개씩 골라서 외적한 벡터들을 모두 살펴본다.
len(nearby) C 2개의 법선벡터 후보들을 normalize한 후 이 평면의 법선벡터와 비슷한 쪽으로 대칭시킨다.
이 벡터들의 산술평균을 계산한다. 또한 표준편차도 계산한다.
# 표준편차가 stdThreshold 이하라면 nearby 점들은 한 평면에 있다. 점 P의 법선벡터를 산술평균 벡터로 지정한다.
# 표준편차가 stdThreshold 이상이라면 nearby 점들은 여러 평면에 있다. 점 P는 경계에 있는 점이다.

2.
경계 점들은 일단 냅두고, 경계가 아닌 점들에 대하여 계층적 클러스터링을 한다. 이때, 오직 법선 벡터만이 고려 대상이 된다.
법선 벡터 기준으로 클러스터링을 일단 했다. 이때 같은 평면이지만 서로 반대방향인 벡터가 있을 수 있으므로
AllPoints 길이를 저장해놓는다. 모든 점을 복제시킨다.
복제시킨 점의 Index는 원래 index + len(allpoints)
복제된 점의 법선벡터는 반대방향
그러면 클러스터될때 대칭 쌍 클러스터가 생기게 된다.
그러면 여기서 타노스 하면 된다.

이 클러스터 안에 있는 법선 벡터들을 모두 평균 낸 벡터를 생각한다. 그 법선 벡터를 갖는 아무 평면 하나를 생각한다. 그다음 각 점들에서 그 평면까지 거리가 있을 것이다. 
그 평면까지의 거리를 리스트에 담아서 정렬시킨다.
인덱스 차례대로 거리들을 보다가 거리가 갑자기 점프하는 경우 새로운 평면으로 취급한다. 그렇게 각각의 새로운 클러스터가 만들어짐.
(*거리가 같은데 서로 다른 평면이 존재할 경우? ex 책상들* 아직 해결못함)
각 클러스터 안에서 RANSAC으로 알맞은 평면을 찾는다. 
경계가 아닌데 경계로 분류되는 fake 경계점들이 좀 있어서 경계점들 안에서 removenoise를 한다. 가짜 경계점들은 서로 멀리 떨어져있다.
아직 평면에 포함시키지 않은 경계 점들과 각 평면들간의 수직 거리들을 모두 계산한다. 각각의 경계 점은 수직 거리가 가장 가까운 평면에 포함이 된다. 경계 점들을 그 평면들에 projection시킨다.
각 평면을 표현하는 방법은 그 평면에 projection된 경계 점들로 표현된다. 경계 점들이 그 평면 위에 있는 다각형의 꼭짓점들이 된다.
